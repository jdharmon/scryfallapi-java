/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.scryfall.api.implementation;

import retrofit2.Retrofit;
import com.scryfall.api.Symbologys;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.scryfall.api.models.CardSymbolList;
import com.scryfall.api.models.ErrorException;
import com.scryfall.api.models.ManaCost;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Symbologys.
 */
public class SymbologysImpl implements Symbologys {
    /** The Retrofit service to perform REST calls. */
    private SymbologysService service;
    /** The service client containing this operation class. */
    private ScryfallClientImpl client;

    /**
     * Initializes an instance of Symbologys.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public SymbologysImpl(Retrofit retrofit, ScryfallClientImpl client) {
        this.service = retrofit.create(SymbologysService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Symbologys to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SymbologysService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.scryfall.api.Symbologys getAll" })
        @GET("symbology")
        Observable<Response<ResponseBody>> getAll();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.scryfall.api.Symbologys parseMana" })
        @GET("symbology/parse-mana")
        Observable<Response<ResponseBody>> parseMana(@Query("cost") String cost);

    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CardSymbolList object if successful.
     */
    public CardSymbolList getAll() {
        return getAllWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CardSymbolList> getAllAsync(final ServiceCallback<CardSymbolList> serviceCallback) {
        return ServiceFuture.fromResponse(getAllWithServiceResponseAsync(), serviceCallback);
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CardSymbolList object
     */
    public Observable<CardSymbolList> getAllAsync() {
        return getAllWithServiceResponseAsync().map(new Func1<ServiceResponse<CardSymbolList>, CardSymbolList>() {
            @Override
            public CardSymbolList call(ServiceResponse<CardSymbolList> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CardSymbolList object
     */
    public Observable<ServiceResponse<CardSymbolList>> getAllWithServiceResponseAsync() {
        return service.getAll()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CardSymbolList>>>() {
                @Override
                public Observable<ServiceResponse<CardSymbolList>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CardSymbolList> clientResponse = getAllDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CardSymbolList> getAllDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<CardSymbolList, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<CardSymbolList>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     *
     * @param cost the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ManaCost object if successful.
     */
    public ManaCost parseMana(String cost) {
        return parseManaWithServiceResponseAsync(cost).toBlocking().single().body();
    }

    /**
     *
     * @param cost the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ManaCost> parseManaAsync(String cost, final ServiceCallback<ManaCost> serviceCallback) {
        return ServiceFuture.fromResponse(parseManaWithServiceResponseAsync(cost), serviceCallback);
    }

    /**
     *
     * @param cost the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManaCost object
     */
    public Observable<ManaCost> parseManaAsync(String cost) {
        return parseManaWithServiceResponseAsync(cost).map(new Func1<ServiceResponse<ManaCost>, ManaCost>() {
            @Override
            public ManaCost call(ServiceResponse<ManaCost> response) {
                return response.body();
            }
        });
    }

    /**
     *
     * @param cost the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the ManaCost object
     */
    public Observable<ServiceResponse<ManaCost>> parseManaWithServiceResponseAsync(String cost) {
        if (cost == null) {
            throw new IllegalArgumentException("Parameter cost is required and cannot be null.");
        }
        return service.parseMana(cost)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ManaCost>>>() {
                @Override
                public Observable<ServiceResponse<ManaCost>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ManaCost> clientResponse = parseManaDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ManaCost> parseManaDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<ManaCost, ErrorException>newInstance(this.client.serializerAdapter())
                .register(201, new TypeToken<ManaCost>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
